---
title: 二分下标
date: 2021-11-13 20:01:17
permalink: /pages/cc5f84/
categories:
  - 算法
  - 二分
tags:
  - 
---

## 概念

就是在有序数组中以 O(logn) 的复杂度找到目标元素

:::danger
前提是数组是有序的，或者是部分有序的（旋转有序数组或者山脉数组）
:::

### 左闭右开写法

个人比较喜欢这种方式

#### 寻找指定元素

找到某个指定元素，如果不存在，返回-1
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
      int n = nums.size();
      int l = 0, r = n;
      while(l < r){
        int mid = l + (r-l)/2;
        if(nums[mid] < target){
          l = mid+1;
        }else if(nums[mid] == target){
          return mid;
        }else{
          r = mid;
        }
      }
      return -1;
    }
};
```

需要注意的有几点，`while` 中的条件，`mid` 取值防溢出， 退出循环时  `left` 和 `right` 的相对关系

:::note
`l = 0, r = n`

在初始化时，left 为数组第一个元素，right 为数组末尾，但是取不到 right，也就是搜索的区间为 [left, right)


`while(l < r)`

如果 left = right，也就是搜索的区间为空了，因此 while 循环退出的条件是 left = right


`if(nums[mid] > target) right = mid`

当发现中间的值比 target 要大，应该压缩右边界，由于 right 取不到，所以 right 可以等于 mid（已经确认mid的元素要大于 target 了）
:::

#### 找到数组中第一个不小于 target 的
找不到返回-1

也就是 lower_bound 的实现，不过 lower_bound 找不到会返回末尾的迭代器（也就是所有元素都比 target 小）

其实就是target第一次出现的位置

:::note 退出循环时有以下几种情况
当所有元素都比 target 小，那么 left 会一直增加到 n

当所有元素都比 target 大，那么 right 会一直减到 0
:::

```cpp
int my_lower_bound(vector<int>&v, int target){
    int n = v.size();
    int l = 0, r = n;

    while(l < r){
        int mid = l + (r-l)/2;
        if(v[mid] < target) l = mid+1;
        else if(v[mid] > target) r = mid;
        else{  // 由于要找到第一个不小于target的，因此在相等时应该压缩右边界
            r = mid;
        }
    }

    if(l == n || v[l] != target) return -1;
    return l;
}
```

#### 找到数组中最后一个不小于 target 的
找不到返回-1

也就是 upper_bound 找到的位置减1，upper_bound 是找到数组中第一个大于 target 的，不过 upper_bound 找不到 target 时会返回末尾迭代器（所有元素都比 target 小）

其实就是 target 最后一次出现的位置


```cpp
int my_upper_bound(vector<int>&v, int target){
    int n = v.size();
    int l = 0, r = n;
    while(l < r){
        int mid = l + (r-l)/2;
        if(v[mid] < target) l = mid+1;
        else if(v[mid] > target) r = mid;
        else{  // 在相等时候，应该压缩左边界
            l = mid+1;
        }
    }

    // 返回的l是第一个比target大的, l-1是最后一个小于等于target的
    if(l == 0 || v[l-1] != target) return -1;  // 所有元素都比target大，那么 l=r=0
    return l-1;
}
```


### 两端闭写法


#### 寻找指定元素

找到某个指定元素，如果不存在，返回-1
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
      int n = nums.size();
      int l = 0, r = n-1;
      while(l <= r){
        int mid = l + (r-l)/2;
        if(nums[mid] < target){
          l = mid+1;
        }else if(nums[mid] == target){
          return mid;
        }else{
          r = mid-1;
        }
      }
      return -1;
    }
};
```

需要注意的有几点，`while` 中的条件，`mid` 取值防溢出， 退出循环时  `left` 和 `right` 的相对关系

:::note
`l = 0, r = n-1`

在初始化时，left 为数组第一个元素，right 为数组最后一个元素，也就是搜索的区间为 [left, right]


`while(l <= r)`

如果 left = right+1，也就是搜索的区间为空了，因此 while 循环退出的条件是 left = right+1


`if(nums[mid] > target) right = mid-1`

当发现中间的值比 target 要大，应该压缩右边界，mid 已经大于 target 了，左边的元素是 mid-1，那么    right=mid-1
:::

#### 找 target 第一次出现的位置

```cpp
int mylow_bound(vector<int>&v, int target){
    int n = v.size();
    int l = 0, r = n-1; 
    while(l <= r){  // 退出循环时 left = right+1
        int mid = l + (r-l)/2;
        if(v[mid] < target)
            l = mid+1;
        else if(v[mid] > target)
            r = mid - 1;
        else  // 在相等的时候，压缩右边界
            r = mid - 1;
    }
    if(l == n || v[l] != target) return -1;
    // 也可以写成 if(r+1 == n || v[r+1] != target) return -1; return r+1;
    return l;
}
```
#### 找 target 最后一次出现的位置

```cpp
int myup_bound(vector<int>&v, int target){
    int n = v.size();
    int l = 0, r = n-1;
    while(l <= r){  // 退出循环时 left = right+1
        int mid = l + (r-l)/2;
        if(v[mid] < target) {
            l = mid+1;
        }else if(v[mid] > target){
            r = mid-1;
        }else{  // 相等时，压缩左边界
            l = mid+1;
        }
    }

    // 在相等时 l=mid+1，那么left一定是大于target的数，因此right小于等于target
    if(r == -1 || v[r] != target) return -1;
    return r;
}
```

## 题目
