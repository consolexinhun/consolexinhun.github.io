---
title: 01背包
date: 2021-11-02 22:21:57
permalink: /pages/37ebac/
categories:
  - 算法
  - 动态规划
tags:
  - 
---

## 思路

### 二维数组

![](https://gitee.com/consolecode/blog-img/raw/master/20211102222826.png)


:::note
base case: 都初始化为 0
:::

::: tip
遍历顺序：可以先遍历物品再遍历背包，也可以先遍历背包再遍历物品
:::

### 滚动数组优化

![](https://gitee.com/consolecode/blog-img/raw/master/20211102231752.png)


## 题目

### HDU 2602

https://acm.hdu.edu.cn/showproblem.php?pid=2602

先输入有多少个物品，然后是总容量

前一行是物品价值，后一行是物品容量
#### 二维数组

```cpp
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        int n, m;
        scanf("%d %d", &n, &m);

        vector<int> w(n, 0), v(n, 0);
        for(int i = 0; i < n; i++) scanf("%d", &v[i]);
        for(int i = 0; i < n; i++) scanf("%d", &w[i]);


        vector<vector<int> > dp(n+1, vector<int>(m+1, 0));
        for(int i = 0; i < n; i++){
            for(int j = 0; j <= m; j++){
                if(w[i] > j) dp[i+1][j] = dp[i][j];
                else{
                    dp[i+1][j] = max(dp[i][j], dp[i][j-w[i]] + v[i]);
                }
            }
        }
        printf("%d\n", dp[n][m]);
    }

    return 0;
}
// 01 背包 2602
// 完全背包 1114
```

#### 滚动数组

```cpp
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        int n, m;
        scanf("%d %d", &n, &m);

        vector<int> w(n, 0), v(n, 0);
        for(int i = 0; i < n; i++) scanf("%d", &v[i]);
        for(int i = 0; i < n; i++) scanf("%d", &w[i]);


        vector<int> dp(m+1, 0);
        for(int i = 0; i < n; i++){
            for(int j = m; j >= 0; j--){
                if(w[i] <= j) // 由于存在物品重量为 0 的情况
                    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
            }
        }
        printf("%d\n", dp[m]);
    }

    return 0;
}


```


## 参考链接

[背包九讲](https://www.kancloud.cn/kancloud/pack/70124)
