---
title: 迪杰斯特拉
categories: 
  - 图论
tags: 
  - 图论
date: 2021-10-18 21:25:55
permalink: /pages/5a514b/
---
HDU 2544

```cpp
//
// Created by Administrator on 2021/10/18.
// 单源最短路 HDU 2544

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<cstring>

const int MAXV = 0x3f3f3f3f;
const int MAXN = 101;

int cost[MAXN][MAXN];

using namespace std;

void dijk(int n){
    int dp[MAXN];  // 到某个点的最短路径
    bool used[MAXN];  // 标记某个点是否走过

    // 初始化，到 i 的路径为1到i的距离
    for(int i = 1; i <= n; i++){
        dp[i] = cost[1][i];  //
        used[i] = false;
    }

    used[1] = true; // 从1开始出发

    int k; // 记录未访问的里面哪个最近

    for(int i = 2; i <= n; i++){

        // 找到未访问的里面离哪个最近
        int minv = MAXV;
        for(int j = 1; j <= n; j++){
            if(!used[j] && dp[j] < minv){
                minv = dp[j];
                k = j;
            }
        }

        used[k] = true; // 访问该节点

        for(int j = 1; j <= n; j++){
            if(!used[j] && dp[k] + cost[k][j] < dp[j]){
                dp[j] = dp[k] + cost[k][j];
            }
        }
    }
    printf("%d\n", dp[n]);
}

int main(){

    int n, m;
    while(scanf("%d %d", &n, &m) && (n || m)){
        memset(cost, 0x3f, sizeof(cost));
        int a, b, c;

        for(int k = 0; k < m; k++){
            scanf("%d %d %d", &a, &b, &c);
            cost[a][b] = cost[b][a] = c;
        }
        dijk(n);
    }
    return 0;
}

```

参考链接：

[OI-wiki](https://oi-wiki.org/graph/shortest-path/#floyd)


