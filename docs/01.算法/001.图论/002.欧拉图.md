---
title: 欧拉图
categories: 
  - 图论
tags: 
  - 图论
---


## 欧拉回路和欧拉通路

### 定义

**欧拉通路**：所有边经过且只经过一次

**欧拉回路**：所有边经过且只经过一次，回到出发点

### 性质

**无向图欧拉通路**：

1、连通图并且有两个奇点或者没有奇点

2、如果连通图有两个奇点，那么欧拉通路必定以两个奇点为端点

3、如果连通图没有奇点，那么必然有欧拉回路


**有向图欧拉通路**：

**判定条件：**

情况一：基图连通，并且所有顶点的入度和出度相等

情况二：基图连通，除两个顶点外，其余点的出度和入度相等，且这两点中，一个出度和入度差为 1，另一个为 -1


推论：

1、欧拉通路必定以出度入度之差为 1 的顶点作为起始点，以出度入度之差为 -1 的顶点作为终点

2、所有顶点出度入度相等时，必定有欧拉回路


### 欧拉通路和回路判断

**判断欧拉通路是否存在**：

有向图：连通，一个顶点出度比入度大 1，另一个顶点入度比出度大 1，其余点出度等于入度

无向图：图连通，只有两个奇点，其余都是偶点

**判断欧拉回路是否存在**：

有向图：连通，所有点出度等于入度

无向图：连通，所有点是偶点


## 题目 


### LC0332 重新安排行程

有向图欧拉回路


https://leetcode-cn.com/problems/reconstruct-itinerary

必定存在一个欧拉回路或者欧拉通路，找到字典序最小的路径


#### DFS 解法

```cpp
class Solution {

private:
    vector<string> result; // 记录遍历的结果
    unordered_map<string, map<string, int>> u; // 某机场能到达的机场，并且记录应该到达几次
public:
    
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for(auto it: tickets){
            u[it[0]][it[1]]++;
        }
        result.push_back("JFK");

        int n = tickets.size(); // 航班数量 
        dfs(n);

        return result;
    }

    bool dfs(int n){
        if(result.size() == n+1) { // 到达的机场数 等于 航班数+1，结束
            return true;
        }

        for(auto &it: u[result[result.size()-1]]){
            if(it.second > 0){
                it.second--;
                result.push_back(it.first);

                if(dfs(n)) return true;

                it.second++;
                result.pop_back();
            }
        }

        return false;
    }


};
```


#### hierholzer 解法

:::tip
图中最多存在一个死胡同，并且这个死胡同最后访问到，否则不能完成一笔画，因此最先加入到栈中，最后输出栈中的结果。

DFS 就是拆边，每次递归删除一条边，所有子递归返回后将当前点加入结果集，递归到死胡同后递归函数返回。
:::



```cpp
class Solution {

private:
    unordered_map<string, vector<string>> u;
    vector<string> res;

public:
    
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for(auto it: tickets){
            u[it[0]].push_back(it[1]);
        }

        for(auto &it: u){
            sort(it.second.begin(), it.second.end());
        }

        int n = tickets.size();
        dfs("JFK", n);

        reverse(res.begin(), res.end());
        return res;
    }

    void dfs(string a, int n){
        while(u[a].size() > 0){
            string k = u[a][0];

            u[a].erase(u[a].begin());

            dfs(k, n);

            res.push_back(a);
        }

        if(res.empty()){  // 这是为了将最后遍历的那个节点加进去
            res.push_back(a);
        }
    }
};

```

另一种写法，加入到结果放在外面

```cpp
class Solution {

private:
    unordered_map<string, vector<string>> u;
    vector<string> res;
public:
    
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for(auto it: tickets){
            u[it[0]].push_back(it[1]);
        }

        for(auto &it: u){
            sort(it.second.begin(), it.second.end());
        }

        dfs("JFK");

        reverse(res.begin(), res.end());
        return res;
    }

    void dfs(string a){
        while(u[a].size() > 0){
            string k = u[a][0];

            u[a].erase(u[a].begin());

            dfs(k);
        }
        res.push_back(a);
    }
};
```

### LC 753



### 洛谷 2731 骑马修栅栏

无向图欧拉回路，并且是整数

https://www.luogu.com.cn/problem/P2731


```cpp
//
// Created by Administrator on 2021/10/19.
//

#include<iostream>
#include<cstdio>
#include<unordered_map>
#include<vector>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;


const int N = 501;
int u[N][N]; // 邻接矩阵建图
unordered_map<int, int> cnt; // 记录每个点出现的次数
vector<int> v; // 记录最终结果，其实是个栈，最后反序就行

int maxn = 0;  // 图上有几个点

void init(){
    memset(u, 0, sizeof(u));
    cnt.clear();
    v.clear();
}

void dfs(int n){
    for(int i = 1; i <= maxn; i++){ // 判断当前点接下来要到哪个点
        if(u[n][i] > 0){
            // 由于是无向图，走了 n 到 i，那么 i 到 n 也要减少
            u[n][i]--;
            u[i][n]--;

            dfs(i);
        }
    }
    v.push_back(n);
}

int main(){
    int m;
    scanf("%d", &m);

    init();

    int a, b;
    for(int k = 0; k < m; k++){
        scanf("%d %d", &a, &b);
        u[a][b]++;
        u[b][a]++;
        cnt[a]++;
        cnt[b]++;

        maxn = max({maxn, a, b});
    }

    bool isOdd = false;
    int minOdd = 0x3f3f3f3f, minEven = 0x3f3f3f3f;
    // 寻找有没有奇点，并且找到最小的奇点和偶点
    for(pair<int, int> t: cnt){
        if(t.second & 1){
            isOdd = true;
            if (t.first < minOdd) minOdd = t.first;
        }
        if(t.first < minEven) minEven = t.first;
    }

    if(isOdd){
        dfs(minOdd);
    }else{
        dfs(minEven);
    }

    reverse(v.begin(), v.end());
    for(int l: v) printf("%d\n", l);

    return 0;
}

```

**参考链接**：

[欧拉回路遍历注意事项：](https://riteme.site/blog/2016-12-13/eular-tour.html)

[欧拉回路基本概念+判断+求解：](https://www.cnblogs.com/wkfvawl/p/9626163.html)