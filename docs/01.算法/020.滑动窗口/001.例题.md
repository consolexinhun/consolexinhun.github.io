---
title: 例题
date: 2021-11-21 19:10:33
permalink: /pages/30b0a0/
categories:
  - 算法
  - 滑动窗口
tags:
  - 
---


## 概念

其实就是一个队列，当不满足要求时移除队列的元素

## 题目

### LC 3. 无重复字符的最长子串

https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

:::tip
用双指针，窗口中存储不重复字符的子串，`i` 表示窗口头，`j`表示窗口尾，用哈希表记录窗口中的字符，当来了一个字符，判断在哈希表中是否出现过

如果未出现过，直接加入到哈希表中，如果出现过，那么不断移动窗口尾指针，直到与窗口头相等为止，移动的过程中不断删除哈希表中的字符。

将尾指针再往前一位，此时从 `j` 到 `i` 的子串仍然不存在重复字符

记录出现过的最长窗口长度。
:::


```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int res = 0;
        unordered_set<char> u;
        int j = 0;
        for(int i = 0; i < (int)s.size(); i++){
            if(u.find(s[i]) != u.end()){ // 找到
                while(s[j] != s[i]){ // 窗口尾不断前移，直到与窗口头一样
                    u.erase(s[j]); // 删除哈希表中的字符
                    j++;
                }
                j++; // 窗口尾再前移一位，保证从j到i是无重复字符的
            }else{
                u.insert(s[i]);
            }
            res = max(res, i-j+1);
        } 
        return res;
    }
};
```


### 76. 最小覆盖子串

https://leetcode-cn.com/problems/minimum-window-substring/

:::tip
滑动窗口，`j`是快指针，`i`是慢指针，当不满足要求时，快指针前移

当满足要求时，慢指针前移，记录出现过的满足要求的最短子串。
:::

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        int n = s.length(), m = t.length();
        if(m > n) return ""; // 母串必须不短于子串

        int a[128];
        int b[128];

        memset(a, 0, sizeof(a));
        memset(b, 0, sizeof(b));

        for(char &c: t) {
            b[(int)c]++;
        }

        int res_len = INT_MAX;
        string res = "";

        int j = 0, i = 0;
        a[(int)s[j]]++;
        while(j < n){
            if(isok(a, b)){
                if(j-i+1 < res_len) {
                    res = s.substr(i, j-i+1);
                    res_len = j-i+1;
                }

                a[(int)s[i]]--;
                i++;
            }else{
                j++;
                a[(int)s[j]]++;
            }
        }

        return res;
    }

    bool isok(int *a, int *b){
        for(int i = 0; i < 128; i++){
            if(a[i] < b[i]) return false;
        }
        return true;
    }
};
```


### 209. 长度最小的子数组

https://leetcode-cn.com/problems/minimum-size-subarray-sum/

### 239. 滑动窗口最大值

https://leetcode-cn.com/problems/sliding-window-maximum/


### 567. 字符串的排列

https://leetcode-cn.com/problems/permutation-in-string/

### 632. 最小区间

https://leetcode-cn.com/problems/smallest-range/
