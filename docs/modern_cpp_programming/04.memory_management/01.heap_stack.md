---
title: heap_stack
date: 2022-08-04 16:37:07
permalink: /pages/8eeaaf/
categories:
  - modern_cpp_programming
  - memory_management
tags:
  - 
---
进程地址空间

![](https://i.imgur.com/OocGYK2.png)

数据段 和 bss 段

```cpp
int data[] = {1, 2}; // DATA segment memory
int big_data[1000000] = {}; // BSS segment memory
// (zero-initialized)
int main() {
    int A[] = {1, 2, 3}; // stack memory
}
```

data 和 bss 比栈内存大，但是访问速度较慢

|                    | 栈                                 | 堆                                              |
| ------------------ | ---------------------------------- | ----------------------------------------------- |
| 内存               | 连续                               | allocation之内是连续的，allocation 之间是分散的 |
| 大小               | 小（linux 下 8MB，Windows 下 1MB） | 整个系统内存                                    |
| 如果超限           | 程序在函数入口时崩溃（很难调试）   | 异常或者空指针                                  |
| allocation（分配） | 编译时                             | 运行时                                          |
| 位置               | 高                                 | 低                                              |
| 线程视角           | 每个线程都有自己的栈               | 所有线程共享                                    |


局部变量要么在栈中，要么在 CPU寄存器里

```cpp
int x = 3; // not on the stack (data segment)
struct A {
    int k; // depends on where the instance of A is
};
int main() {
    int y = 3; // on stack
    char z[] = "abc"; // on stack
    A a; // on stack (also k)
    void* ptr = malloc(4); // variable "ptr" is on the stack
}

```

栈性能更高，但是栈的空间有限


存在栈里的数据类型：

* 局部变量
* 函数参数
* 函数返回值
* 编译器的特别指令
* 中断上下文


栈中每个对象在作用域外是无效的

```cpp
int* f() {
    int array[3] = {1, 2, 3};
    return array;
}
int* ptr = f();
cout << ptr[0]; // Illegal memory access!! A
```


```cpp
void g(bool x) {
    const char* str = "abc";
    if (x) {
        char xyz[] = "xyz";
        str = xyz;
    }
    cout << str; // if "x" is true, then Illegal memory access!! A
}
```


`new/new[]` 和 `delete/delete[]` 是C++ 关键字，用于进行动态内存分配/回收，以及在运行时对象的构造和销毁

`malloc` 和 `free` 是C关键字，分配和释放内存块（以字节为单位）


new 和 delete 的优点：

- 语言关键字：不是函数，更加安全
- 返回值类型：new 返回精准的数据类型，而 malloc 返回 void*
- 失败：new 抛异常，malloc 返回空指针
- 分配类型：new 分配的内存单元大小由编译器计算，malloc 必须手动计算分配多少字节
- 初始化：除了分配内存单元，new 还可以初始化
- 多态：带有虚函数的对象必须使用 new 分配


动态内存分配：


分配单个值：

```cpp
int* value = (int*) malloc(sizeof(int)); // C
int* value = new int; // C++
```

分配 N 个元素

```cpp
int* array = (int*) malloc(N * sizeof(int)); // C
int* array = new int[N]; // C++
```

分配 N 个结构体

```cpp
MyStruct* array = (int*) malloc(N * sizeof(MyStruct)); // C
MyStruct* array = new MyStruct[N]; // C++
```

分配并零初始化 N 个元素

```cpp
int* array = (int*) calloc(N, sizeof(int)); // C
int* array = new int[N](); // C++
```


释放单个元素

```cpp
int* value = (int*) malloc(sizeof(int)); // C
free(value);
int* value = new int; // C++
delete value;

```

释放 N 个元素

```cpp
int* value = (int*) malloc(N * sizeof(int)); // C
free(value);
int* value = new int[N]; // C++
delete[] value;

```
